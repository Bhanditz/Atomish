Atomish
=======

Concepts
--------

- Reified 'things'.
    The readers, evallers, printers, universes, runloops, and mirrors as such are *reified* - that is, they are not merely 'things', but have an actual existance as actual things that can be manipulated, created and destroyed in the language itself. This means that people can write their own 'things' - indeed, this is how things like the 'Sugar' level of the language are made.
- Message sends
    Atomish is more Smalltalky than Lispy or Forthy; in the base language, juxtaposition is sending, rather than application or concatenation. Message chain rewriting and generalised places are used to solve some of the aesthetic problems of pure sending.
- Aesthetic model


Levels
------

The Atomish Language has levels. Code can be written at any of the levels. Each level is bootstrapped by code written in the level below it.

- PreAtomish
    The PreAtomish language is used for bootstrapping the Atomish language proper. It is a restricted subset of the Atomish language. There is an interpreter written for it in Scala. It does have a limited amount of sugar 'built in', rather than 'built out'.
- Core
    The Atomish language as such. Core does not have any built in sugar. Little code in Core is written by hand; it is mostly generated by 'desugaring' higher level code.
- Sugar
    The sugar is the standard set of modules with extended readers, evallers, printers, universes, runloops, mirrors, and also things like MMOP functions and reader macros. This 'builds out' facilities like rewriting and generalised places in a way that is extendable. Importantly, the only thing differentiating the 'official' Sugar from other sugar is coming prepackaged.
- Libraries
    Libraries can extend the function of a language without actually having to extend the language as such.

Types of things
---------------

###Message sends

###Basic object model

###Basic literals

####Numbers

####Strings

####Regexes

###Expressions


- Cells
- Message sends
- MOP, MMOP
- Generalised Places 
- Destructuring
- Modules - via Structure/Signature/Functor route, with exports a la CommonJS.
- Macros, reader macros, lecros
- Quoting, quasiquoting (Lisp/Ioke style, Haskell style, and MetaLua style), unquoting, funquoting
- Patterns
- Extractors
- Closures
- Morphisms - Cata, Ana, Hylo, Apo, Zygo, Histo, Prepro
- Monads, MonadTransformers
- Arrows

Syntax
------

String, Regex, symbol, number (decimal, rational, integer), associative array, set, list/array/seq, Boolean, kv (ie for Dicts and named args), cell

Read Eval 'Print' loop

Reader is a function in the language

Mirrors

Eval is a function in the language

Layout heralds

Equational reasoning/particles/cases/extractors

Sections


\#
--

- Generic reader macro start character. Not meaningful by itself.


؟, #;, #.
--
- Comment forms
- ؟ is an ironic comment - terminates at a newline
- #; is a normal comment which terminates at a newline
- #. is a normal comment which terminates at a ".", consuming that ".". It is thus useful for multiline and inline comments.

\#!
--
- Bangline

!
--
- Call a function with no arguments

‼, !!
--
- Fixpoint call; keep calling until the result is not a nullary function
- Fixpoint call with args - keep calling until the result is not a function that takes those args

'
--
- Quoter


''
--
- Quasiquoter


\`
--
- Unquoter

\`\*
--
- Unquote splicing


\#'
--
- Funquoter


\`\_
--
- Hole


\*
--
- Splat, bezirt transform, blask


λ 
--
- Alias to fn


× ÷ + - ^
--
- Arithmetic operators


:
---
- Forms a list on the right and applies it to the left - make explicit the elements of a set (done via a list apply monad) - monads in do-notation - Syntactical-descriptive
- Describes the left with the right ie key-value relationships (the value describes the key), for example in Dicts or Arglists - Appositive
- Forming (or receiving implicitly formed) a closure/continuation/(ruby style)-block - Segmental


;
---
- Starts a subclause (whatever that means...)


.
---
- Finish a line - acts like a newline.


" ", « », / /, { }, [ ], &lt; &gt;
---

- MMOPery - ie for something like
  qw&lt;foo bar baz&gt; each(import)
- Use vs mention distinction
- The left op is the 'indent', the right op is the 'dedent'. In a whitespace sensitive reader, actual indents and dedents would also count on this list. Relevant to code scoping, but with MMOPery also relevant to (for example) a YAML literal reader.
- The types of quote are named by symbols: sw&lt;quotes guillemet slash curly square angle any&gt;
- Standard MMOPs:
    - cell :"" for quote type :quotes - string constructor with interpolation
    - cell :"" for quote type :slash - regexp constructor without interpolation
    - cell :"" for quote type :curly - dictionary constructor
    - cell :"" for quote type :square - list constructor
    - cell :"#r" for quote type :square - regexp constructor with interpolation
    - cell :"#" for quote type :square - string constructor with interpolation
    - cell :"qw" for any quote type :angle - take string, create array by splitting on spaces, no escapes or interpolation
    - cell :"sw" for any quote type :angle - take string, create array by splitting on spaces and converting to symbols, no escapes or interpolation
    - cell :"#" for quote type :curly - set constructor
    - cell :"mf" for quote type :guillemet - math style function - single letter variables, juxtaposition = multiplication. Results in a function with named args for each of the variables used.
    - cell :"me" for quote type :guillemet - math style expression - single letter variables, juxtaposition = multiplication. Results in an expression.

_
---
- Lots of stuff. Anonymous functions, empty matches... Also, other things. The evil reflection of \*.

,
---
- A comma splice. No, really.
- The separator between arguments in an argument list, the items in a set, list or dictionary, and so forth.

…
---
- Ignore an immediately following newline. In effect, the current line continues on the next line.


Other things
---

§ + a name closes that section
∘ for function application
Datalang, query lang, qq lang ...


Example:
--------

        let(page, #'(html
                      (head title `_)
                      (body
                        (section
                          h1 `_
                          span(class: `_) `_
                          div " I'm all in "
                          (div `_)))),
            stuff, qw<Hello.atomish Hello fragment World!. bits.>,
            Byeloblog render(page(*stuff)) println)
